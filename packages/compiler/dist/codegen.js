"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateJS = generateJS;
function generateJS(ir) {
    const lines = [];
    const emit = (s) => lines.push(s);
    emit(`// Generated by BrainWeb Compiler — ${ir.name}`);
    emit(`// Do not edit by hand.`);
    emit(``);
    // Inline runtime
    emit(RUNTIME_SOURCE);
    emit(``);
    // App graph as JSON
    emit(`const __BW_GRAPH__ = ${JSON.stringify(ir, null, 2)};`);
    emit(``);
    // Collect all event types for encoder
    const allEventTypes = new Set();
    for (const sensor of ir.sensors) {
        for (const et of sensor.eventTypes) {
            allEventTypes.add(et);
        }
    }
    const eventTypeList = Array.from(allEventTypes);
    // createApp function
    emit(`function createApp(fx, opts) {`);
    emit(`  opts = opts || {};`);
    emit(`  const seed = opts.seed || 12345;`);
    emit(`  const debug = opts.debug !== undefined ? opts.debug : true;`);
    emit(``);
    emit(`  // Event queue`);
    emit(`  const eventQueue = new BwEventQueue();`);
    emit(``);
    // Sensors
    emit(`  // Sensor wiring`);
    emit(`  const sensorConfigs = ${JSON.stringify(ir.sensors)};`);
    emit(`  let cleanupSensors = null;`);
    emit(``);
    // Encoder
    const encoder = ir.encoders[0];
    if (encoder) {
        emit(`  // Encoder`);
        emit(`  const encoder = new BwEncoder({`);
        emit(`    dim: ${encoder.dim},`);
        emit(`    featureOps: ${JSON.stringify(encoder.featureOps)},`);
        emit(`    eventTypeList: ${JSON.stringify(eventTypeList)},`);
        emit(`  });`);
        emit(``);
    }
    // Context memory
    const ctxModule = ir.modules.find(m => m.kind === "State");
    if (ctxModule && ctxModule.kind === "State") {
        emit(`  // Context memory`);
        emit(`  const contextMemory = new BwContextMemory({`);
        emit(`    slots: ${ctxModule.slots},`);
        emit(`    decayMs: ${ctxModule.decayMs},`);
        emit(`    featureDim: ${encoder?.dim ?? 32},`);
        emit(`    merge: ${JSON.stringify(ctxModule.merge)},`);
        emit(`  });`);
        emit(``);
    }
    // Action selector
    const actionSel = ir.modules.find(m => m.kind === "ActionSelector");
    if (actionSel && actionSel.kind === "ActionSelector") {
        emit(`  // Action selector`);
        emit(`  const actionSelector = new BwActionSelector({`);
        emit(`    actions: ${JSON.stringify(actionSel.actions)},`);
        emit(`    featureDim: ${encoder?.dim ?? 32},`);
        emit(`    temperature: ${actionSel.temperature},`);
        emit(`    seed: seed,`);
        emit(`  });`);
        emit(``);
    }
    // Effect table
    emit(`  // Effect table`);
    emit(`  const effectTable = {};`);
    for (const eff of ir.effectors) {
        for (const b of eff.bindings) {
            if (b.kind === "js" && b.expr) {
                emit(`  effectTable[${JSON.stringify(b.action)}] = function(ctx) { return ${b.expr}; };`);
            }
            else {
                emit(`  effectTable[${JSON.stringify(b.action)}] = function() {};`);
            }
        }
    }
    emit(``);
    // Guards
    emit(`  // Guards`);
    emit(`  const guards = new BwGuardChain(${JSON.stringify(ir.runtime.guards)});`);
    emit(``);
    // Debug
    emit(`  // Debug overlay + recorder`);
    emit(`  const debugOverlay = new BwDebugOverlay(debug);`);
    emit(`  const recorder = new BwRecorder();`);
    emit(``);
    // State
    emit(`  let currentCtx = { target: "", eventType: "", features: new Float32Array(${encoder?.dim ?? 32}) };`);
    emit(`  let lastEvents = [];`);
    emit(``);
    // Runtime loop
    const tickConfig = ir.runtime.tick;
    emit(`  // Runtime loop`);
    emit(`  const loop = new BwRuntimeLoop(${JSON.stringify(tickConfig)});`);
    emit(``);
    // Step plan
    emit(`  loop.setSteps([`);
    emit(`    // Ingest events`);
    emit(`    function ingestStep(now) {`);
    emit(`      lastEvents = eventQueue.drain();`);
    emit(`      for (const ev of lastEvents) {`);
    emit(`        recorder.recordEvent(ev);`);
    emit(`      }`);
    emit(`    },`);
    if (encoder) {
        emit(`    // Encode`);
        emit(`    function encodeStep(now) {`);
        emit(`      if (lastEvents.length === 0) return;`);
        emit(`      const features = encoder.encode(lastEvents, now);`);
        if (ctxModule) {
            emit(`      const meta = lastEvents.length > 0 ? lastEvents[lastEvents.length - 1].payload : {};`);
            emit(`      meta.eventType = lastEvents.length > 0 ? lastEvents[lastEvents.length - 1].type : "";`);
            emit(`      currentCtx = contextMemory.step(features, meta, now);`);
        }
        emit(`    },`);
    }
    if (actionSel) {
        emit(`    // Action selection + effect emission`);
        emit(`    function actionStep(now) {`);
        emit(`      if (lastEvents.length === 0) return;`);
        emit(`      const result = actionSelector.step(currentCtx.features);`);
        emit(`      const actions = actionSelector.getActions();`);
        emit(`      const winner = actions[result.winner];`);
        emit(``);
        emit(`      // Guard check`);
        emit(`      const allowed = guards.check(winner, now);`);
        emit(``);
        emit(`      // Debug update`);
        emit(`      debugOverlay.update({`);
        emit(`        lastEvents: lastEvents,`);
        emit(`        contextTarget: currentCtx.target || "",`);
        emit(`        contextEventType: currentCtx.eventType || "",`);
        emit(`        actionValues: Array.from(result.values),`);
        emit(`        actionProbs: Array.from(result.probs),`);
        emit(`        actionNames: actions,`);
        emit(`        winner: winner,`);
        emit(`        guardRejection: allowed ? null : guards.lastRejection,`);
        emit(`      });`);
        emit(``);
        emit(`      // Record`);
        emit(`      recorder.recordAction(now, winner, !allowed);`);
        emit(``);
        emit(`      // Emit effect`);
        emit(`      if (allowed && effectTable[winner]) {`);
        emit(`        try {`);
        emit(`          effectTable[winner](currentCtx);`);
        emit(`          guards.record(winner, now);`);
        emit(`        } catch(e) {`);
        emit(`          console.error("[BrainWeb] Effect error:", e);`);
        emit(`        }`);
        emit(`      }`);
        emit(`    },`);
    }
    emit(`  ]);`);
    emit(``);
    // Public API
    emit(`  return {`);
    emit(`    start: function() {`);
    emit(`      cleanupSensors = bwWireSensors(sensorConfigs, eventQueue);`);
    emit(`      loop.start();`);
    emit(`    },`);
    emit(`    stop: function() {`);
    emit(`      loop.stop();`);
    emit(`      if (cleanupSensors) cleanupSensors();`);
    emit(`    },`);
    emit(`    startRecording: function() { recorder.start(); },`);
    emit(`    stopRecording: function() { return recorder.stop(); },`);
    emit(`    replay: function(entries) {`);
    emit(`      loop.stop();`);
    emit(`      if (cleanupSensors) cleanupSensors();`);
    emit(`      cleanupSensors = null;`);
    emit(`      for (const entry of entries) {`);
    emit(`        if (entry.event) {`);
    emit(`          eventQueue.push(entry.event);`);
    emit(`        }`);
    emit(`      }`);
    emit(`      // Run one tick to process all replayed events`);
    emit(`      const steps = loop._getSteps ? loop._getSteps() : [];`);
    emit(`      const now = performance.now();`);
    emit(`      for (const step of steps) step(now);`);
    emit(`    },`);
    emit(`    getGraph: function() { return __BW_GRAPH__; },`);
    emit(`    destroy: function() {`);
    emit(`      loop.stop();`);
    emit(`      if (cleanupSensors) cleanupSensors();`);
    emit(`      debugOverlay.destroy();`);
    emit(`    },`);
    emit(`  };`);
    emit(`}`);
    emit(``);
    emit(`// Export for browser`);
    emit(`if (typeof window !== "undefined") {`);
    emit(`  window.BrainWeb = { createApp: createApp };`);
    emit(`}`);
    return lines.join("\n");
}
// Inlined runtime -- plain JS that runs directly in browser
const RUNTIME_SOURCE = `
// ── BrainWeb Runtime (inlined) ──

// MurmurHash3 32-bit
function bwMurmurHash3(key, seed) {
  seed = seed || 0;
  var h = seed >>> 0;
  var len = key.length;
  var i = 0;
  while (i + 4 <= len) {
    var k = (key.charCodeAt(i) & 0xff) |
            ((key.charCodeAt(i+1) & 0xff) << 8) |
            ((key.charCodeAt(i+2) & 0xff) << 16) |
            ((key.charCodeAt(i+3) & 0xff) << 24);
    k = Math.imul(k, 0xcc9e2d51);
    k = (k << 15) | (k >>> 17);
    k = Math.imul(k, 0x1b873593);
    h ^= k;
    h = (h << 13) | (h >>> 19);
    h = Math.imul(h, 5) + 0xe6546b64;
    i += 4;
  }
  var k2 = 0;
  switch (len - i) {
    case 3: k2 ^= (key.charCodeAt(i+2) & 0xff) << 16;
    case 2: k2 ^= (key.charCodeAt(i+1) & 0xff) << 8;
    case 1:
      k2 ^= key.charCodeAt(i) & 0xff;
      k2 = Math.imul(k2, 0xcc9e2d51);
      k2 = (k2 << 15) | (k2 >>> 17);
      k2 = Math.imul(k2, 0x1b873593);
      h ^= k2;
  }
  h ^= len;
  h ^= h >>> 16;
  h = Math.imul(h, 0x85ebca6b);
  h ^= h >>> 13;
  h = Math.imul(h, 0xc2b2ae35);
  h ^= h >>> 16;
  return h >>> 0;
}

// Event Queue
function BwEventQueue() { this.buf = []; }
BwEventQueue.prototype.push = function(ev) { this.buf.push(ev); };
BwEventQueue.prototype.drain = function() {
  if (this.buf.length === 0) return [];
  var events = this.buf; this.buf = []; return events;
};

// Sensor Wiring
function bwCssPath(el) {
  if (!el || el === document.body) return "body";
  var parts = [];
  var cur = el;
  while (cur && cur !== document.body) {
    var sel = cur.tagName.toLowerCase();
    if (cur.id) { sel += "#" + cur.id; parts.unshift(sel); break; }
    if (cur.className && typeof cur.className === "string") {
      sel += "." + cur.className.trim().split(/\\s+/).join(".");
    }
    parts.unshift(sel);
    cur = cur.parentElement;
  }
  return parts.join(" > ");
}

var BW_DOM_MAP = {
  Click: "click", Input: "input", KeyDown: "keydown", KeyUp: "keyup",
  Scroll: "scroll", Focus: "focus", Blur: "blur", MouseMove: "mousemove",
  VisibilityChange: "visibilitychange"
};

function bwNormalizePayload(ev) {
  var p = {};
  if (ev instanceof MouseEvent) {
    p.clientX = ev.clientX; p.clientY = ev.clientY; p.button = ev.button;
    p.target = bwCssPath(ev.target);
  } else if (ev instanceof KeyboardEvent) {
    p.key = ev.key; p.code = ev.code; p.target = bwCssPath(ev.target);
  } else if (ev.target && "value" in ev.target) {
    p.inputLen = ev.target.value ? ev.target.value.length : 0;
    p.target = bwCssPath(ev.target);
  }
  if (ev.type === "scroll") { p.scrollY = window.scrollY; p.scrollX = window.scrollX; }
  return p;
}

function bwWireSensors(configs, queue) {
  var cleanups = [];
  for (var i = 0; i < configs.length; i++) {
    var cfg = configs[i];
    for (var j = 0; j < cfg.eventTypes.length; j++) {
      (function(sensorName, evType) {
        var domEv = BW_DOM_MAP[evType];
        if (!domEv) return;
        var handler = function(ev) {
          queue.push({
            sensor: sensorName, type: evType,
            t: performance.now(), payload: bwNormalizePayload(ev)
          });
        };
        document.addEventListener(domEv, handler, { passive: true });
        cleanups.push(function() { document.removeEventListener(domEv, handler); });
      })(cfg.name, cfg.eventTypes[j]);
    }
  }
  return function() { for (var k = 0; k < cleanups.length; k++) cleanups[k](); };
}

// Encoder
function BwEncoder(config) {
  this.dim = config.dim;
  this.ops = config.featureOps;
  this.output = new Float32Array(config.dim);
  this.eventTypeList = config.eventTypeList;
  this.lastEventTime = 0;
}
BwEncoder.prototype.encode = function(events, now) {
  this.output.fill(0);
  if (events.length === 0) return this.output;
  var ev = events[events.length - 1];
  var offset = 0;
  for (var i = 0; i < this.ops.length; i++) {
    var op = this.ops[i];
    switch (op.kind) {
      case "onehot": {
        var idx = this.eventTypeList.indexOf(ev.type);
        var slots = Math.min(this.eventTypeList.length, this.dim - offset);
        if (idx >= 0 && idx < slots) this.output[offset + idx] = 1.0;
        offset += slots;
        break;
      }
      case "bucket": {
        var bins = op.bins || 16;
        var dt = now - this.lastEventTime;
        var normalized = Math.min(dt / 10000, 1.0);
        var bucket = Math.min(Math.floor(normalized * bins), bins - 1);
        if (offset + bucket < this.dim) this.output[offset + bucket] = 1.0;
        offset += bins;
        break;
      }
      case "hash": {
        var buckets = op.buckets || 32;
        var value = String(ev.payload && ev.payload[op.field] || ev.payload && ev.payload.target || "");
        var h = bwMurmurHash3(value, 42);
        var hIdx = h % buckets;
        if (offset + hIdx < this.dim) this.output[offset + hIdx] = 1.0;
        offset += buckets;
        break;
      }
      case "numeric": {
        var val = Number(ev.payload && ev.payload[op.field] || 0);
        var norm = val / (1 + Math.abs(val));
        if (offset < this.dim) this.output[offset] = norm;
        offset += 1;
        break;
      }
      case "clamp": {
        var raw = Number(ev.payload && ev.payload[op.field] || 0);
        var clamped = Math.max(op.min || 0, Math.min(op.max || 1, raw));
        if (offset < this.dim) this.output[offset] = clamped;
        offset += 1;
        break;
      }
      case "scale": {
        var rawV = Number(ev.payload && ev.payload[op.field] || 0);
        if (offset < this.dim) this.output[offset] = rawV * (op.factor || 1);
        offset += 1;
        break;
      }
    }
  }
  this.lastEventTime = now;
  return this.output;
};

// Context Memory
function BwContextMemory(config) {
  this.slots = config.slots;
  this.decayMs = config.decayMs;
  this.featureDim = config.featureDim;
  this.slotData = [];
  this.slotTimes = [];
  this.slotMeta = [];
  this.writeIdx = 0;
  for (var i = 0; i < this.slots; i++) {
    this.slotData.push(new Float32Array(this.featureDim));
    this.slotTimes.push(0);
    this.slotMeta.push({});
  }
}
BwContextMemory.prototype.step = function(features, meta, now) {
  var i, j;
  for (i = 0; i < this.slots; i++) {
    var age = now - this.slotTimes[i];
    if (this.slotTimes[i] > 0 && age > 0) {
      var decay = Math.exp(-age / this.decayMs);
      var d = this.slotData[i];
      for (j = 0; j < this.featureDim; j++) d[j] *= decay;
    }
  }
  var slot = this.slotData[this.writeIdx];
  var copyLen = Math.min(features.length, this.featureDim);
  for (j = 0; j < copyLen; j++) slot[j] = features[j];
  this.slotTimes[this.writeIdx] = now;
  this.slotMeta[this.writeIdx] = Object.assign({}, meta);
  this.writeIdx = (this.writeIdx + 1) % this.slots;

  var aggregated = new Float32Array(this.featureDim);
  var totalW = 0;
  for (i = 0; i < this.slots; i++) {
    if (this.slotTimes[i] === 0) continue;
    var a = now - this.slotTimes[i];
    var w = Math.exp(-a / this.decayMs);
    totalW += w;
    var sd = this.slotData[i];
    for (j = 0; j < this.featureDim; j++) aggregated[j] += sd[j] * w;
  }
  if (totalW > 0) { for (j = 0; j < this.featureDim; j++) aggregated[j] /= totalW; }

  var latestMeta = {}, latestTime = 0;
  for (i = 0; i < this.slots; i++) {
    if (this.slotTimes[i] > latestTime) { latestTime = this.slotTimes[i]; latestMeta = this.slotMeta[i]; }
  }
  return { target: latestMeta.target || "", eventType: latestMeta.eventType || "", features: aggregated };
};

// Action Selector
function bwXorshift32(state) {
  state ^= state << 13;
  state ^= state >> 17;
  state ^= state << 5;
  return state;
}
function bwSoftmax(input, output, temperature) {
  var n = input.length, max = -Infinity;
  for (var i = 0; i < n; i++) { var v = input[i] / temperature; if (v > max) max = v; }
  var sum = 0;
  for (var i = 0; i < n; i++) { var e = Math.exp(input[i] / temperature - max); output[i] = e; sum += e; }
  if (sum > 0) { for (var i = 0; i < n; i++) output[i] /= sum; }
}
function BwActionSelector(config) {
  this.actions = config.actions;
  this.featureDim = config.featureDim;
  this.temperature = config.temperature;
  var n = config.actions.length;
  this.values = new Float32Array(n);
  this.probs = new Float32Array(n);
  this.weights = new Float32Array(n * config.featureDim);
  var rng = config.seed;
  for (var i = 0; i < this.weights.length; i++) {
    rng = bwXorshift32(rng);
    this.weights[i] = ((rng >>> 0) / 0xffffffff - 0.5) * 0.1;
  }
}
BwActionSelector.prototype.step = function(contextFeatures) {
  var n = this.actions.length;
  for (var a = 0; a < n; a++) {
    var sum = 0, base = a * this.featureDim;
    for (var j = 0; j < this.featureDim; j++) {
      sum += this.weights[base + j] * (contextFeatures[j] || 0);
    }
    this.values[a] = sum;
  }
  bwSoftmax(this.values, this.probs, this.temperature);
  var winner = 0, maxVal = this.probs[0];
  for (var a = 1; a < n; a++) {
    if (this.probs[a] > maxVal) { maxVal = this.probs[a]; winner = a; }
  }
  return { winner: winner, values: new Float32Array(this.values), probs: new Float32Array(this.probs) };
};
BwActionSelector.prototype.getActions = function() { return this.actions; };

// Guards
function BwGuardChain(configs) {
  this.configs = configs;
  this.recentEffects = [];
  this.lastRejection = null;
}
BwGuardChain.prototype.check = function(action, now) {
  this.lastRejection = null;
  for (var i = 0; i < this.configs.length; i++) {
    var g = this.configs[i];
    if (g.kind === "max_effects_per_sec") {
      var limit = g.limit || 10;
      var cutoff = now - 1000;
      var count = 0;
      for (var j = 0; j < this.recentEffects.length; j++) {
        if (this.recentEffects[j].t > cutoff) count++;
      }
      if (count >= limit) { this.lastRejection = "max_effects_per_sec (" + count + "/" + limit + ")"; return false; }
    }
    if (g.kind === "suppress_repeats") {
      var windowMs = g.windowMs || 1000;
      var cutoff2 = now - windowMs;
      for (var j = 0; j < this.recentEffects.length; j++) {
        if (this.recentEffects[j].t > cutoff2 && this.recentEffects[j].action === action) {
          this.lastRejection = 'suppress_repeats ("' + action + '" within ' + windowMs + 'ms)';
          return false;
        }
      }
    }
  }
  return true;
};
BwGuardChain.prototype.record = function(action, now) {
  this.recentEffects.push({ t: now, action: action });
  var cutoff = now - 5000;
  while (this.recentEffects.length > 0 && this.recentEffects[0].t < cutoff) this.recentEffects.shift();
};

// Runtime Loop
function BwRuntimeLoop(config) {
  this.config = config;
  this.steps = [];
  this.running = false;
  this.rafId = 0;
  this.intervalId = 0;
}
BwRuntimeLoop.prototype.setSteps = function(steps) { this.steps = steps; };
BwRuntimeLoop.prototype._getSteps = function() { return this.steps; };
BwRuntimeLoop.prototype.start = function() {
  if (this.running) return;
  this.running = true;
  var self = this;
  if (this.config.mode === "RAF") {
    var tick = function() {
      if (!self.running) return;
      var now = performance.now();
      self._runSteps(now);
      self.rafId = requestAnimationFrame(tick);
    };
    this.rafId = requestAnimationFrame(tick);
  } else {
    var ms = this.config.ms || 100;
    this.intervalId = setInterval(function() {
      var now = performance.now();
      self._runSteps(now);
    }, ms);
  }
};
BwRuntimeLoop.prototype.stop = function() {
  this.running = false;
  if (this.rafId) cancelAnimationFrame(this.rafId);
  if (this.intervalId) clearInterval(this.intervalId);
};
BwRuntimeLoop.prototype._runSteps = function(now) {
  for (var i = 0; i < this.steps.length; i++) {
    try { this.steps[i](now); } catch(e) { console.error("[BrainWeb] Step error:", e); this.stop(); return; }
  }
};

// Debug Overlay
function BwDebugOverlay(enabled) {
  this.container = null;
  this.enabled = enabled;
  this.state = {
    lastEvents: [], contextTarget: "", contextEventType: "",
    actionValues: [], actionProbs: [], actionNames: [],
    winner: "", guardRejection: null
  };
  if (enabled && typeof document !== "undefined") this._create();
}
BwDebugOverlay.prototype._create = function() {
  this.container = document.createElement("div");
  this.container.id = "bw-debug-overlay";
  this.container.style.cssText =
    "position:fixed;bottom:0;right:0;width:360px;max-height:50vh;" +
    "overflow-y:auto;background:rgba(15,15,25,0.92);color:#e0e0e0;" +
    "font-family:'SF Mono',Consolas,monospace;font-size:11px;" +
    "padding:10px;z-index:999999;border-top-left-radius:8px;" +
    "border-left:1px solid rgba(100,100,255,0.3);" +
    "border-top:1px solid rgba(100,100,255,0.3);" +
    "backdrop-filter:blur(8px);";
  document.body.appendChild(this.container);
};
BwDebugOverlay.prototype.update = function(partial) {
  for (var k in partial) { if (partial.hasOwnProperty(k)) this.state[k] = partial[k]; }
  if (!this.enabled || !this.container) return;
  this._render();
};
BwDebugOverlay.prototype._render = function() {
  if (!this.container) return;
  var s = this.state;
  var evHtml = s.lastEvents.slice(-5).map(function(e) {
    return '<div style="padding:1px 0;color:#8cf">' + e.sensor + '.' + e.type +
      ' <span style="color:#666">' + (e.payload && e.payload.target || "") + '</span></div>';
  }).join("");
  var actHtml = s.actionNames.map(function(name, i) {
    var isW = name === s.winner;
    var bar = "";
    for (var b = 0; b < Math.round((s.actionProbs[i] || 0) * 20); b++) bar += "\\u2588";
    var st = isW ? "color:#5f5;font-weight:bold" : "color:#aaa";
    return '<div style="' + st + '">' + (isW ? "\\u25b8" : " ") + " " + name + ": " +
      (s.actionProbs[i] || 0).toFixed(3) + " " + bar + "</div>";
  }).join("");
  var gHtml = s.guardRejection
    ? '<div style="color:#f88;padding:2px 0">\\u2298 ' + s.guardRejection + '</div>' : "";
  this.container.innerHTML =
    '<div style="color:#88f;font-weight:bold;margin-bottom:4px">BrainWeb Debug</div>' +
    '<div style="margin-bottom:6px"><div style="color:#888;font-size:10px">EVENTS</div>' +
    (evHtml || '<div style="color:#555">none</div>') + '</div>' +
    '<div style="margin-bottom:6px"><div style="color:#888;font-size:10px">CONTEXT</div>' +
    '<div>target: <span style="color:#cf8">' + (s.contextTarget || "\\u2014") + '</span></div>' +
    '<div>event: <span style="color:#cf8">' + (s.contextEventType || "\\u2014") + '</span></div></div>' +
    '<div style="margin-bottom:6px"><div style="color:#888;font-size:10px">ACTIONS</div>' +
    (actHtml || '<div style="color:#555">none</div>') + '</div>' +
    gHtml +
    '<div style="margin-top:4px;color:#888;font-size:10px">Winner: <span style="color:#5f5;font-weight:bold">' +
    (s.winner || "\\u2014") + '</span></div>';
};
BwDebugOverlay.prototype.destroy = function() {
  if (this.container) this.container.remove();
  this.container = null;
};

// Recorder
function BwRecorder() { this.entries = []; this.recording = false; }
BwRecorder.prototype.start = function() { this.entries = []; this.recording = true; };
BwRecorder.prototype.stop = function() { this.recording = false; return this.entries; };
BwRecorder.prototype.isRecording = function() { return this.recording; };
BwRecorder.prototype.recordEvent = function(ev) {
  if (!this.recording) return;
  this.entries.push({ t: ev.t, event: ev });
};
BwRecorder.prototype.recordAction = function(t, winner, guardRejected) {
  if (!this.recording) return;
  this.entries.push({ t: t, winner: winner, guardRejected: guardRejected });
};
`;
//# sourceMappingURL=codegen.js.map