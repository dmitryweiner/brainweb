// Generated by BrainWeb Compiler — SmartDashboard
// Do not edit by hand.


// ── BrainWeb Runtime (inlined) ──

// MurmurHash3 32-bit
function bwMurmurHash3(key, seed) {
  seed = seed || 0;
  var h = seed >>> 0;
  var len = key.length;
  var i = 0;
  while (i + 4 <= len) {
    var k = (key.charCodeAt(i) & 0xff) |
            ((key.charCodeAt(i+1) & 0xff) << 8) |
            ((key.charCodeAt(i+2) & 0xff) << 16) |
            ((key.charCodeAt(i+3) & 0xff) << 24);
    k = Math.imul(k, 0xcc9e2d51);
    k = (k << 15) | (k >>> 17);
    k = Math.imul(k, 0x1b873593);
    h ^= k;
    h = (h << 13) | (h >>> 19);
    h = Math.imul(h, 5) + 0xe6546b64;
    i += 4;
  }
  var k2 = 0;
  switch (len - i) {
    case 3: k2 ^= (key.charCodeAt(i+2) & 0xff) << 16;
    case 2: k2 ^= (key.charCodeAt(i+1) & 0xff) << 8;
    case 1:
      k2 ^= key.charCodeAt(i) & 0xff;
      k2 = Math.imul(k2, 0xcc9e2d51);
      k2 = (k2 << 15) | (k2 >>> 17);
      k2 = Math.imul(k2, 0x1b873593);
      h ^= k2;
  }
  h ^= len;
  h ^= h >>> 16;
  h = Math.imul(h, 0x85ebca6b);
  h ^= h >>> 13;
  h = Math.imul(h, 0xc2b2ae35);
  h ^= h >>> 16;
  return h >>> 0;
}

// Event Queue
function BwEventQueue() { this.buf = []; }
BwEventQueue.prototype.push = function(ev) { this.buf.push(ev); };
BwEventQueue.prototype.drain = function() {
  if (this.buf.length === 0) return [];
  var events = this.buf; this.buf = []; return events;
};
BwEventQueue.prototype.getLength = function() { return this.buf.length; };

// Sensor Wiring
function bwCssPath(el) {
  if (!el || el === document.body) return "body";
  var parts = [];
  var cur = el;
  while (cur && cur !== document.body) {
    var sel = cur.tagName.toLowerCase();
    if (cur.id) { sel += "#" + cur.id; parts.unshift(sel); break; }
    if (cur.className && typeof cur.className === "string") {
      sel += "." + cur.className.trim().split(/\s+/).join(".");
    }
    parts.unshift(sel);
    cur = cur.parentElement;
  }
  return parts.join(" > ");
}

var BW_DOM_MAP = {
  Click: "click", Input: "input", KeyDown: "keydown", KeyUp: "keyup",
  Scroll: "scroll", Focus: "focus", Blur: "blur", MouseMove: "mousemove",
  VisibilityChange: "visibilitychange"
};

function bwNormalizePayload(ev) {
  var p = {};
  if (ev instanceof MouseEvent) {
    p.clientX = ev.clientX; p.clientY = ev.clientY; p.button = ev.button;
    p.target = bwCssPath(ev.target);
  } else if (ev instanceof KeyboardEvent) {
    p.key = ev.key; p.code = ev.code; p.target = bwCssPath(ev.target);
  } else if (ev.target && "value" in ev.target) {
    p.inputLen = ev.target.value ? ev.target.value.length : 0;
    p.target = bwCssPath(ev.target);
  }
  if (ev.type === "scroll") { p.scrollY = window.scrollY; p.scrollX = window.scrollX; }
  return p;
}

function bwWireSensors(configs, queue) {
  var cleanups = [];
  for (var i = 0; i < configs.length; i++) {
    var cfg = configs[i];
    for (var j = 0; j < cfg.eventTypes.length; j++) {
      (function(sensorName, evType) {
        var domEv = BW_DOM_MAP[evType];
        if (!domEv) return;
        var handler = function(ev) {
          queue.push({
            sensor: sensorName, type: evType,
            t: performance.now(), payload: bwNormalizePayload(ev)
          });
        };
        document.addEventListener(domEv, handler, { passive: true });
        cleanups.push(function() { document.removeEventListener(domEv, handler); });
      })(cfg.name, cfg.eventTypes[j]);
    }
  }
  return function() { for (var k = 0; k < cleanups.length; k++) cleanups[k](); };
}

// Encoder
function BwEncoder(config) {
  this.dim = config.dim;
  this.ops = config.featureOps;
  this.output = new Float32Array(config.dim);
  this.eventTypeList = config.eventTypeList;
  this.lastEventTime = 0;
}
BwEncoder.prototype.encode = function(events, now) {
  this.output.fill(0);
  if (events.length === 0) return this.output;
  var ev = events[events.length - 1];
  var offset = 0;
  for (var i = 0; i < this.ops.length; i++) {
    var op = this.ops[i];
    switch (op.kind) {
      case "onehot": {
        var idx = this.eventTypeList.indexOf(ev.type);
        var slots = Math.min(this.eventTypeList.length, this.dim - offset);
        if (idx >= 0 && idx < slots) this.output[offset + idx] = 1.0;
        offset += slots;
        break;
      }
      case "bucket": {
        var bins = op.bins || 16;
        var dt = now - this.lastEventTime;
        var normalized = Math.min(dt / 10000, 1.0);
        var bucket = Math.min(Math.floor(normalized * bins), bins - 1);
        if (offset + bucket < this.dim) this.output[offset + bucket] = 1.0;
        offset += bins;
        break;
      }
      case "hash": {
        var buckets = op.buckets || 32;
        var value = String(ev.payload && ev.payload[op.field] || ev.payload && ev.payload.target || "");
        var h = bwMurmurHash3(value, 42);
        var hIdx = h % buckets;
        if (offset + hIdx < this.dim) this.output[offset + hIdx] = 1.0;
        offset += buckets;
        break;
      }
      case "numeric": {
        var val = Number(ev.payload && ev.payload[op.field] || 0);
        var norm = val / (1 + Math.abs(val));
        if (offset < this.dim) this.output[offset] = norm;
        offset += 1;
        break;
      }
      case "clamp": {
        var raw = Number(ev.payload && ev.payload[op.field] || 0);
        var clamped = Math.max(op.min || 0, Math.min(op.max || 1, raw));
        if (offset < this.dim) this.output[offset] = clamped;
        offset += 1;
        break;
      }
      case "scale": {
        var rawV = Number(ev.payload && ev.payload[op.field] || 0);
        if (offset < this.dim) this.output[offset] = rawV * (op.factor || 1);
        offset += 1;
        break;
      }
    }
  }
  this.lastEventTime = now;
  return this.output;
};
BwEncoder.prototype.getOpRanges = function() {
  var ranges = [];
  var offset = 0;
  for (var i = 0; i < this.ops.length; i++) {
    var op = this.ops[i];
    var len = 0;
    switch (op.kind) {
      case "onehot": len = Math.min(this.eventTypeList.length, this.dim - offset); break;
      case "bucket": len = op.bins || 16; break;
      case "hash": len = op.buckets || 32; break;
      case "numeric": case "clamp": case "scale": len = 1; break;
    }
    ranges.push({ kind: op.kind, field: op.field || "", offset: offset, len: len });
    offset += len;
  }
  return ranges;
};

// Context Memory
function BwContextMemory(config) {
  this.slots = config.slots;
  this.decayMs = config.decayMs;
  this.featureDim = config.featureDim;
  this.slotData = [];
  this.slotTimes = [];
  this.slotMeta = [];
  this.writeIdx = 0;
  for (var i = 0; i < this.slots; i++) {
    this.slotData.push(new Float32Array(this.featureDim));
    this.slotTimes.push(0);
    this.slotMeta.push({});
  }
}
BwContextMemory.prototype.step = function(features, meta, now) {
  var i, j;
  for (i = 0; i < this.slots; i++) {
    var age = now - this.slotTimes[i];
    if (this.slotTimes[i] > 0 && age > 0) {
      var decay = Math.exp(-age / this.decayMs);
      var d = this.slotData[i];
      for (j = 0; j < this.featureDim; j++) d[j] *= decay;
    }
  }
  var slot = this.slotData[this.writeIdx];
  var copyLen = Math.min(features.length, this.featureDim);
  for (j = 0; j < copyLen; j++) slot[j] = features[j];
  this.slotTimes[this.writeIdx] = now;
  this.slotMeta[this.writeIdx] = Object.assign({}, meta);
  this.writeIdx = (this.writeIdx + 1) % this.slots;

  var aggregated = new Float32Array(this.featureDim);
  var totalW = 0;
  for (i = 0; i < this.slots; i++) {
    if (this.slotTimes[i] === 0) continue;
    var a = now - this.slotTimes[i];
    var w = Math.exp(-a / this.decayMs);
    totalW += w;
    var sd = this.slotData[i];
    for (j = 0; j < this.featureDim; j++) aggregated[j] += sd[j] * w;
  }
  if (totalW > 0) { for (j = 0; j < this.featureDim; j++) aggregated[j] /= totalW; }

  var latestMeta = {}, latestTime = 0;
  for (i = 0; i < this.slots; i++) {
    if (this.slotTimes[i] > latestTime) { latestTime = this.slotTimes[i]; latestMeta = this.slotMeta[i]; }
  }
  return { target: latestMeta.target || "", eventType: latestMeta.eventType || "", features: aggregated };
};
BwContextMemory.prototype.getSlotInfo = function(now) {
  var info = [];
  for (var i = 0; i < this.slots; i++) {
    var age = now - this.slotTimes[i];
    var w = this.slotTimes[i] > 0 ? Math.exp(-age / this.decayMs) : 0;
    var energy = 0;
    var d = this.slotData[i];
    for (var j = 0; j < this.featureDim; j++) energy += d[j] * d[j];
    energy = Math.sqrt(energy);
    info.push({
      index: i,
      active: this.slotTimes[i] > 0,
      age: age,
      decayWeight: w,
      energy: energy,
      target: (this.slotMeta[i] && this.slotMeta[i].target) || "",
      eventType: (this.slotMeta[i] && this.slotMeta[i].eventType) || ""
    });
  }
  return info;
};

// Action Selector
function bwXorshift32(state) {
  state ^= state << 13;
  state ^= state >> 17;
  state ^= state << 5;
  return state;
}
function bwSoftmax(input, output, temperature) {
  var n = input.length, max = -Infinity;
  for (var i = 0; i < n; i++) { var v = input[i] / temperature; if (v > max) max = v; }
  var sum = 0;
  for (var i = 0; i < n; i++) { var e = Math.exp(input[i] / temperature - max); output[i] = e; sum += e; }
  if (sum > 0) { for (var i = 0; i < n; i++) output[i] /= sum; }
}
function BwActionSelector(config) {
  this.actions = config.actions;
  this.featureDim = config.featureDim;
  this.temperature = config.temperature;
  var n = config.actions.length;
  this.values = new Float32Array(n);
  this.probs = new Float32Array(n);
  this.weights = new Float32Array(n * config.featureDim);
  var rng = config.seed;
  for (var i = 0; i < this.weights.length; i++) {
    rng = bwXorshift32(rng);
    this.weights[i] = ((rng >>> 0) / 0xffffffff - 0.5) * 0.1;
  }
}
BwActionSelector.prototype.step = function(contextFeatures) {
  var n = this.actions.length;
  for (var a = 0; a < n; a++) {
    var sum = 0, base = a * this.featureDim;
    for (var j = 0; j < this.featureDim; j++) {
      sum += this.weights[base + j] * (contextFeatures[j] || 0);
    }
    this.values[a] = sum;
  }
  bwSoftmax(this.values, this.probs, this.temperature);
  var winner = 0, maxVal = this.probs[0];
  for (var a = 1; a < n; a++) {
    if (this.probs[a] > maxVal) { maxVal = this.probs[a]; winner = a; }
  }
  return { winner: winner, values: new Float32Array(this.values), probs: new Float32Array(this.probs) };
};
BwActionSelector.prototype.getActions = function() { return this.actions; };

// Guards
function BwGuardChain(configs) {
  this.configs = configs;
  this.recentEffects = [];
  this.lastRejection = null;
}
BwGuardChain.prototype.check = function(action, now) {
  this.lastRejection = null;
  for (var i = 0; i < this.configs.length; i++) {
    var g = this.configs[i];
    if (g.kind === "max_effects_per_sec") {
      var limit = g.limit || 10;
      var cutoff = now - 1000;
      var count = 0;
      for (var j = 0; j < this.recentEffects.length; j++) {
        if (this.recentEffects[j].t > cutoff) count++;
      }
      if (count >= limit) { this.lastRejection = "max_effects_per_sec (" + count + "/" + limit + ")"; return false; }
    }
    if (g.kind === "suppress_repeats") {
      var windowMs = g.windowMs || 1000;
      var cutoff2 = now - windowMs;
      for (var j = 0; j < this.recentEffects.length; j++) {
        if (this.recentEffects[j].t > cutoff2 && this.recentEffects[j].action === action) {
          this.lastRejection = 'suppress_repeats ("' + action + '" within ' + windowMs + 'ms)';
          return false;
        }
      }
    }
  }
  return true;
};
BwGuardChain.prototype.record = function(action, now) {
  this.recentEffects.push({ t: now, action: action });
  var cutoff = now - 5000;
  while (this.recentEffects.length > 0 && this.recentEffects[0].t < cutoff) this.recentEffects.shift();
};
BwGuardChain.prototype.getRecentEffects = function() { return this.recentEffects.slice(); };

// Runtime Loop
function BwRuntimeLoop(config) {
  this.config = config;
  this.steps = [];
  this.running = false;
  this.rafId = 0;
  this.intervalId = 0;
}
BwRuntimeLoop.prototype.setSteps = function(steps) { this.steps = steps; };
BwRuntimeLoop.prototype._getSteps = function() { return this.steps; };
BwRuntimeLoop.prototype.start = function() {
  if (this.running) return;
  this.running = true;
  var self = this;
  if (this.config.mode === "RAF") {
    var tick = function() {
      if (!self.running) return;
      var now = performance.now();
      self._runSteps(now);
      self.rafId = requestAnimationFrame(tick);
    };
    this.rafId = requestAnimationFrame(tick);
  } else {
    var ms = this.config.ms || 100;
    this.intervalId = setInterval(function() {
      var now = performance.now();
      self._runSteps(now);
    }, ms);
  }
};
BwRuntimeLoop.prototype.stop = function() {
  this.running = false;
  if (this.rafId) cancelAnimationFrame(this.rafId);
  if (this.intervalId) clearInterval(this.intervalId);
};
BwRuntimeLoop.prototype._runSteps = function(now) {
  for (var i = 0; i < this.steps.length; i++) {
    try { this.steps[i](now); } catch(e) { console.error("[BrainWeb] Step error:", e); this.stop(); return; }
  }
};

// Debug Overlay
function BwDebugOverlay(enabled) {
  this.container = null;
  this._toggleBtn = null;
  this.enabled = enabled;
  this._collapsed = {};
  this._minimized = false;
  this._lastRenderTime = 0;
  this._sections = ["events","queue","encoder","context","actions","weights","guards","pipeline"];
  this.state = {
    lastEvents: [], contextTarget: "", contextEventType: "",
    actionValues: [], actionProbs: [], actionNames: [],
    winner: "", guardRejection: null,
    featureVector: null, encoderOps: [],
    contextSlots: [], guardHistory: [],
    eventQueueLen: 0, pipelineSteps: [],
    tickStats: { fps: 0, eventsPerSec: 0, actionsPerSec: 0, tickMs: 0 },
    weightMatrix: null
  };
  if (enabled && typeof document !== "undefined") this._create();
}
BwDebugOverlay.prototype._create = function() {
  this.container = document.createElement("div");
  this.container.id = "bw-debug-overlay";
  this.container.style.cssText =
    "position:fixed;bottom:0;right:0;width:380px;max-height:60vh;" +
    "overflow-y:auto;background:rgba(15,15,25,0.95);color:#e0e0e0;" +
    "font-family:'SF Mono',Consolas,monospace;font-size:11px;" +
    "padding:10px;z-index:999999;border-top-left-radius:8px;" +
    "border-left:1px solid rgba(100,100,255,0.3);" +
    "border-top:1px solid rgba(100,100,255,0.3);" +
    "backdrop-filter:blur(8px);transition:opacity 0.2s;";
  var self = this;
  this.container.addEventListener("click", function(e) {
    var el = e.target;
    while (el && el !== self.container) {
      if (el.dataset && el.dataset.bwClose !== undefined) {
        self._setMinimized(true);
        return;
      }
      if (el.dataset && el.dataset.bwFoldAll !== undefined) {
        self._toggleFoldAll();
        return;
      }
      if (el.dataset && el.dataset.bwSection) {
        self._collapsed[el.dataset.bwSection] = !self._collapsed[el.dataset.bwSection];
        self._render();
        return;
      }
      el = el.parentElement;
    }
  });
  document.body.appendChild(this.container);
  this._toggleBtn = document.createElement("div");
  this._toggleBtn.id = "bw-debug-toggle";
  this._toggleBtn.style.cssText =
    "position:fixed;bottom:12px;right:12px;width:36px;height:36px;" +
    "border-radius:50%;background:rgba(15,15,25,0.9);color:#88f;" +
    "font-family:'SF Mono',Consolas,monospace;font-size:11px;font-weight:bold;" +
    "display:none;align-items:center;justify-content:center;cursor:pointer;" +
    "z-index:999999;border:1px solid rgba(100,100,255,0.4);" +
    "box-shadow:0 2px 8px rgba(0,0,0,0.4);transition:transform 0.2s;user-select:none;";
  this._toggleBtn.textContent = "BW";
  this._toggleBtn.title = "Open BrainWeb Debug";
  this._toggleBtn.addEventListener("mouseenter", function() { this.style.transform = "scale(1.1)"; });
  this._toggleBtn.addEventListener("mouseleave", function() { this.style.transform = "scale(1)"; });
  this._toggleBtn.addEventListener("click", function() { self._setMinimized(false); });
  document.body.appendChild(this._toggleBtn);
};
BwDebugOverlay.prototype._setMinimized = function(v) {
  this._minimized = v;
  if (this.container) this.container.style.display = v ? "none" : "block";
  if (this._toggleBtn) this._toggleBtn.style.display = v ? "flex" : "none";
};
BwDebugOverlay.prototype._toggleFoldAll = function() {
  var allFolded = true;
  for (var i = 0; i < this._sections.length; i++) {
    if (!this._collapsed[this._sections[i]]) { allFolded = false; break; }
  }
  for (var i = 0; i < this._sections.length; i++) {
    this._collapsed[this._sections[i]] = !allFolded;
  }
  this._render();
};
BwDebugOverlay.prototype.update = function(partial) {
  for (var k in partial) { if (partial.hasOwnProperty(k)) this.state[k] = partial[k]; }
  if (!this.enabled || !this.container) return;
  var now = performance.now();
  if (now - this._lastRenderTime < 100) return;
  this._lastRenderTime = now;
  this._render();
};
BwDebugOverlay.prototype._secHdr = function(id, label) {
  var c = this._collapsed[id];
  var arrow = c ? "\u25b6" : "\u25bc";
  return '<div data-bw-section="' + id + '" style="color:#99a;font-size:10px;font-weight:600;cursor:pointer;user-select:none;padding:4px 6px;margin:2px -6px;border-radius:4px;transition:background 0.15s" onmouseenter="this.style.background='rgba(100,100,255,0.1)'" onmouseleave="this.style.background='transparent'">' + arrow + '  ' + label + '</div>';
};
BwDebugOverlay.prototype._heatCell = function(val, mx) {
  var t = mx > 0 ? Math.min(Math.abs(val) / mx, 1) : 0;
  var r = Math.round(20 + t * 60);
  var g = Math.round(20 + t * 100);
  var b = Math.round(40 + t * 215);
  return '<span style="display:inline-block;width:4px;height:10px;background:rgb(' + r + ',' + g + ',' + b + ')" title="' + val.toFixed(4) + '"></span>';
};
BwDebugOverlay.prototype._weightCell = function(val) {
  var t = Math.min(Math.abs(val) * 20, 1);
  var r, g, b;
  if (val < 0) { r = Math.round(40 + t * 200); g = Math.round(30 + t * 30); b = Math.round(30 + t * 30); }
  else { r = Math.round(30 + t * 30); g = Math.round(30 + t * 30); b = Math.round(40 + t * 200); }
  return '<span style="display:inline-block;width:4px;height:4px;background:rgb(' + r + ',' + g + ',' + b + ')" title="' + val.toFixed(5) + '"></span>';
};
BwDebugOverlay.prototype._render = function() {
  if (!this.container) return;
  var s = this.state;
  var html = '';
  var ts = s.tickStats || {};

  // Header with stats and controls
  html += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">';
  html += '<div style="color:#88f;font-weight:bold">BrainWeb Debug</div>';
  html += '<div style="display:flex;align-items:center;gap:8px">';
  html += '<span style="font-size:9px">';
  html += '<span style="color:#8f8">' + (ts.fps || 0).toFixed(0) + ' fps</span> ';
  html += '<span style="color:#88f">' + (ts.eventsPerSec || 0).toFixed(0) + ' ev/s</span> ';
  html += '<span style="color:#f8f">' + (ts.actionsPerSec || 0).toFixed(0) + ' act/s</span>';
  html += '</span>';
  var allFolded = true;
  for (var _fi = 0; _fi < this._sections.length; _fi++) { if (!this._collapsed[this._sections[_fi]]) { allFolded = false; break; } }
  html += '<span data-bw-fold-all style="cursor:pointer;color:#666;font-size:9px;padding:2px 4px;border-radius:3px;border:1px solid #333;user-select:none" title="' + (allFolded ? 'Unfold all' : 'Fold all') + '">' + (allFolded ? '\u25bc all' : '\u25b6 all') + '</span>';
  html += '<span data-bw-close style="cursor:pointer;color:#666;font-size:14px;line-height:1;padding:0 2px;user-select:none" title="Close debug panel">\u00d7</span>';
  html += '</div></div>';

  // EVENTS with full payload
  html += this._secHdr("events", "EVENTS");
  if (!this._collapsed["events"]) {
    if (s.lastEvents.length === 0) {
      html += '<div style="color:#555;margin-bottom:6px">none</div>';
    } else {
      html += '<div style="margin-bottom:6px">';
      var evs = s.lastEvents.slice(-5);
      for (var ei = 0; ei < evs.length; ei++) {
        var ev = evs[ei];
        html += '<div style="padding:1px 0;color:#8cf">' + ev.sensor + '.' + ev.type;
        if (ev.payload) {
          var parts = [];
          for (var pk in ev.payload) {
            if (ev.payload.hasOwnProperty(pk)) {
              var pv = ev.payload[pk];
              if (typeof pv === "number") pv = Math.round(pv * 100) / 100;
              parts.push('<span style="color:#666">' + pk + '=</span><span style="color:#aaa">' + pv + '</span>');
            }
          }
          if (parts.length > 0) html += ' <span style="font-size:9px">' + parts.join(" ") + '</span>';
        }
        html += '</div>';
      }
      html += '</div>';
    }
  }

  // EVENT QUEUE
  html += this._secHdr("queue", "EVENT QUEUE");
  if (!this._collapsed["queue"]) {
    var ql = s.eventQueueLen || 0;
    var qbar = "";
    for (var qi = 0; qi < Math.min(ql, 30); qi++) qbar += "\u2588";
    html += '<div style="margin-bottom:6px;color:' + (ql > 0 ? "#ff8" : "#555") + '">';
    html += 'pending: ' + ql + ' ' + qbar + '</div>';
  }

  // ENCODER feature vector heatmap + ops
  html += this._secHdr("encoder", "ENCODER");
  if (!this._collapsed["encoder"]) {
    html += '<div style="margin-bottom:6px">';
    if (s.featureVector && s.featureVector.length > 0) {
      var fv = s.featureVector;
      var fvMax = 0;
      for (var fi = 0; fi < fv.length; fi++) { if (Math.abs(fv[fi]) > fvMax) fvMax = Math.abs(fv[fi]); }
      html += '<div style="font-size:9px;color:#888;margin-bottom:2px">features [' + fv.length + 'd] max=' + fvMax.toFixed(3) + '</div>';
      html += '<div style="line-height:10px;letter-spacing:0">';
      for (var fi = 0; fi < fv.length; fi++) {
        html += this._heatCell(fv[fi], fvMax);
      }
      html += '</div>';
      if (s.encoderOps && s.encoderOps.length > 0) {
        var opCols = ["#68f", "#f86", "#8f6", "#f6f", "#ff6", "#6ff"];
        html += '<div style="margin-top:3px;font-size:9px">';
        for (var oi = 0; oi < s.encoderOps.length; oi++) {
          var op = s.encoderOps[oi];
          var oc = opCols[oi % opCols.length];
          html += '<span style="color:' + oc + '">[' + op.offset + '-' + (op.offset + op.len - 1) + '] ' + op.kind;
          if (op.field) html += '(' + op.field + ')';
          html += '</span> ';
        }
        html += '</div>';
      }
    } else {
      html += '<div style="color:#555">no features</div>';
    }
    html += '</div>';
  }

  // CONTEXT MEMORY
  html += this._secHdr("context", "CONTEXT MEMORY");
  if (!this._collapsed["context"]) {
    html += '<div style="margin-bottom:6px">';
    html += '<div>target: <span style="color:#cf8">' + (s.contextTarget || "\u2014") + '</span></div>';
    html += '<div>event: <span style="color:#cf8">' + (s.contextEventType || "\u2014") + '</span></div>';
    if (s.contextSlots && s.contextSlots.length > 0) {
      html += '<div style="margin-top:3px;font-size:9px;color:#888">slots:</div>';
      for (var ci = 0; ci < s.contextSlots.length; ci++) {
        var cs = s.contextSlots[ci];
        if (!cs.active) {
          html += '<div style="color:#444;font-size:9px">[' + cs.index + '] empty</div>';
        } else {
          var ageStr = cs.age < 1000 ? Math.round(cs.age) + 'ms' : (cs.age / 1000).toFixed(1) + 's';
          var wBar = "";
          var wLen = Math.round(cs.decayWeight * 10);
          for (var wi = 0; wi < wLen; wi++) wBar += "\u2588";
          html += '<div style="font-size:9px">';
          html += '<span style="color:#68f">[' + cs.index + ']</span> ';
          html += '<span style="color:#aaa">age=' + ageStr + '</span> ';
          html += '<span style="color:#8f8">w=' + cs.decayWeight.toFixed(2) + ' ' + wBar + '</span> ';
          html += '<span style="color:#888">E=' + cs.energy.toFixed(3) + '</span> ';
          if (cs.target) html += '<span style="color:#666">' + cs.target.substring(0, 20) + '</span>';
          html += '</div>';
        }
      }
    }
    html += '</div>';
  }

  // ACTIONS with raw values
  html += this._secHdr("actions", "ACTIONS");
  if (!this._collapsed["actions"]) {
    html += '<div style="margin-bottom:6px">';
    if (s.actionNames.length === 0) {
      html += '<div style="color:#555">none</div>';
    } else {
      for (var ai = 0; ai < s.actionNames.length; ai++) {
        var aName = s.actionNames[ai];
        var isW = aName === s.winner;
        var prob = s.actionProbs[ai] || 0;
        var rawV = s.actionValues[ai] !== undefined ? s.actionValues[ai] : 0;
        var bar = "";
        for (var ab = 0; ab < Math.round(prob * 20); ab++) bar += "\u2588";
        var st = isW ? "color:#5f5;font-weight:bold" : "color:#aaa";
        html += '<div style="' + st + '">' + (isW ? "\u25b8" : " ") + " " + aName + ": ";
        html += prob.toFixed(3) + " " + bar;
        html += ' <span style="color:#666;font-size:9px">raw=' + rawV.toFixed(4) + '</span>';
        html += '</div>';
      }
    }
    html += '</div>';
  }

  // WEIGHT MATRIX
  html += this._secHdr("weights", "WEIGHT MATRIX");
  if (!this._collapsed["weights"]) {
    html += '<div style="margin-bottom:6px">';
    if (s.weightMatrix && s.weightMatrix.weights) {
      var wm = s.weightMatrix;
      var dim = wm.featureDim;
      var acts = wm.actions;
      html += '<div style="font-size:9px;color:#888;margin-bottom:2px">' + acts.length + ' actions \u00d7 ' + dim + ' features</div>';
      for (var wa = 0; wa < acts.length; wa++) {
        html += '<div style="line-height:5px;margin-bottom:1px">';
        html += '<span style="font-size:8px;color:#888;display:inline-block;width:50px;overflow:hidden;text-overflow:ellipsis;vertical-align:top">' + acts[wa].substring(0, 7) + '</span>';
        var base = wa * dim;
        for (var wf = 0; wf < dim; wf++) {
          html += this._weightCell(wm.weights[base + wf]);
        }
        html += '</div>';
      }
    } else {
      html += '<div style="color:#555">no weights</div>';
    }
    html += '</div>';
  }

  // GUARDS
  html += this._secHdr("guards", "GUARDS");
  if (!this._collapsed["guards"]) {
    html += '<div style="margin-bottom:6px">';
    if (s.guardRejection) {
      html += '<div style="color:#f88;padding:2px 0">\u2298 ' + s.guardRejection + '</div>';
    }
    if (s.guardHistory && s.guardHistory.length > 0) {
      html += '<div style="font-size:9px;color:#888;margin-top:2px">recent effects:</div>';
      var gh = s.guardHistory.slice(-8);
      var ghNow = performance.now();
      for (var gi = 0; gi < gh.length; gi++) {
        var ge = gh[gi];
        var gAge = ghNow - ge.t;
        var gAgeStr = gAge < 1000 ? Math.round(gAge) + 'ms' : (gAge / 1000).toFixed(1) + 's';
        html += '<div style="font-size:9px"><span style="color:#f86">' + ge.action + '</span> <span style="color:#666">' + gAgeStr + ' ago</span></div>';
      }
    } else if (!s.guardRejection) {
      html += '<div style="color:#555">no recent effects</div>';
    }
    html += '</div>';
  }

  // PIPELINE
  html += this._secHdr("pipeline", "PIPELINE");
  if (!this._collapsed["pipeline"]) {
    html += '<div style="margin-bottom:6px">';
    if (s.pipelineSteps && s.pipelineSteps.length > 0) {
      var maxDur = 0;
      for (var pi = 0; pi < s.pipelineSteps.length; pi++) {
        if (s.pipelineSteps[pi].durationMs > maxDur) maxDur = s.pipelineSteps[pi].durationMs;
      }
      for (var pi = 0; pi < s.pipelineSteps.length; pi++) {
        var ps = s.pipelineSteps[pi];
        var pbar = "";
        var pLen = maxDur > 0 ? Math.round((ps.durationMs / maxDur) * 15) : 0;
        for (var pb = 0; pb < pLen; pb++) pbar += "\u2588";
        html += '<div style="font-size:9px">';
        html += '<span style="color:#68f;display:inline-block;width:55px">' + ps.name + '</span>';
        html += '<span style="color:#aaa">' + ps.durationMs.toFixed(2) + 'ms</span> ';
        html += '<span style="color:#446">' + pbar + '</span>';
        html += '</div>';
      }
      html += '<div style="font-size:9px;color:#888;margin-top:1px">tick: ' + (ts.tickMs || 0).toFixed(2) + 'ms</div>';
    } else {
      html += '<div style="color:#555">no data</div>';
    }
    html += '</div>';
  }

  // Winner
  html += '<div style="margin-top:4px;color:#888;font-size:10px">Winner: <span style="color:#5f5;font-weight:bold">' +
    (s.winner || "\u2014") + '</span></div>';

  this.container.innerHTML = html;
};
BwDebugOverlay.prototype.destroy = function() {
  if (this.container) this.container.remove();
  if (this._toggleBtn) this._toggleBtn.remove();
  this.container = null;
  this._toggleBtn = null;
};

// Recorder
function BwRecorder() { this.entries = []; this.recording = false; }
BwRecorder.prototype.start = function() { this.entries = []; this.recording = true; };
BwRecorder.prototype.stop = function() { this.recording = false; return this.entries; };
BwRecorder.prototype.isRecording = function() { return this.recording; };
BwRecorder.prototype.recordEvent = function(ev) {
  if (!this.recording) return;
  this.entries.push({ t: ev.t, event: ev });
};
BwRecorder.prototype.recordAction = function(t, winner, guardRejected) {
  if (!this.recording) return;
  this.entries.push({ t: t, winner: winner, guardRejected: guardRejected });
};


const __BW_GRAPH__ = {
  "name": "SmartDashboard",
  "sensors": [
    {
      "name": "UI",
      "eventTypes": [
        "Click",
        "Input",
        "KeyDown",
        "Focus",
        "Blur"
      ]
    },
    {
      "name": "Mouse",
      "eventTypes": [
        "MouseMove",
        "Scroll"
      ]
    }
  ],
  "encoders": [
    {
      "name": "Enc",
      "inputs": [
        {
          "sensor": "UI",
          "event": "*"
        },
        {
          "sensor": "Mouse",
          "event": "*"
        }
      ],
      "dim": 128,
      "featureOps": [
        {
          "kind": "onehot",
          "field": "EventType"
        },
        {
          "kind": "bucket",
          "field": "TimeDelta",
          "bins": 16
        },
        {
          "kind": "hash",
          "field": "TargetCssPath",
          "buckets": 64
        },
        {
          "kind": "numeric",
          "field": "scrollY"
        },
        {
          "kind": "clamp",
          "field": "inputLen",
          "min": 0,
          "max": 100
        },
        {
          "kind": "scale",
          "field": "clientX",
          "factor": 0.001
        }
      ]
    }
  ],
  "modules": [
    {
      "kind": "State",
      "name": "Cortex__Memory",
      "slots": 8,
      "decayMs": 10000,
      "merge": "overwrite"
    },
    {
      "kind": "Rate",
      "name": "Gate__AV",
      "units": 6
    },
    {
      "kind": "Rate",
      "name": "Gate__W",
      "units": 6
    },
    {
      "kind": "ActionSelector",
      "name": "Gate",
      "actions": [
        "HighlightWidget",
        "SuggestTask",
        "CollapseIdle",
        "RefreshFeed",
        "ShowShortcut",
        "Ignore"
      ],
      "temperature": 0.7
    }
  ],
  "projections": [
    {
      "from": "Gate__AV",
      "to": "Gate__W",
      "topology": {
        "kind": "softmax",
        "temperature": 0.7
      },
      "init": {
        "kind": "default"
      }
    }
  ],
  "effectors": [
    {
      "name": "Eff",
      "bindings": [
        {
          "action": "HighlightWidget",
          "kind": "js",
          "expr": "fx.highlightWidget(ctx)"
        },
        {
          "action": "SuggestTask",
          "kind": "js",
          "expr": "fx.suggestTask(ctx)"
        },
        {
          "action": "CollapseIdle",
          "kind": "js",
          "expr": "fx.collapseIdle(ctx)"
        },
        {
          "action": "RefreshFeed",
          "kind": "js",
          "expr": "fx.refreshFeed(ctx)"
        },
        {
          "action": "ShowShortcut",
          "kind": "js",
          "expr": "fx.showShortcut(ctx)"
        },
        {
          "action": "Ignore",
          "kind": "noop"
        }
      ]
    }
  ],
  "runtime": {
    "tick": {
      "mode": "Interval",
      "ms": 1000
    },
    "steps": [
      {
        "kind": "ingest",
        "sensors": [
          "UI",
          "Mouse"
        ]
      },
      {
        "kind": "run",
        "module": "Enc"
      },
      {
        "kind": "run",
        "module": "Cortex.Memory"
      },
      {
        "kind": "run",
        "module": "Gate"
      },
      {
        "kind": "emit",
        "effector": "Eff",
        "from": "Gate.W",
        "winnerOnly": true
      }
    ],
    "guards": [
      {
        "kind": "max_effects_per_sec",
        "limit": 2
      },
      {
        "kind": "suppress_repeats",
        "windowMs": 5000
      }
    ]
  }
};

function createApp(fx, opts) {
  opts = opts || {};
  const seed = opts.seed || 12345;
  const debug = opts.debug !== undefined ? opts.debug : true;

  // Event queue
  const eventQueue = new BwEventQueue();

  // Sensor wiring
  const sensorConfigs = [{"name":"UI","eventTypes":["Click","Input","KeyDown","Focus","Blur"]},{"name":"Mouse","eventTypes":["MouseMove","Scroll"]}];
  let cleanupSensors = null;

  // Encoder
  const encoder = new BwEncoder({
    dim: 128,
    featureOps: [{"kind":"onehot","field":"EventType"},{"kind":"bucket","field":"TimeDelta","bins":16},{"kind":"hash","field":"TargetCssPath","buckets":64},{"kind":"numeric","field":"scrollY"},{"kind":"clamp","field":"inputLen","min":0,"max":100},{"kind":"scale","field":"clientX","factor":0.001}],
    eventTypeList: ["Click","Input","KeyDown","Focus","Blur","MouseMove","Scroll"],
  });

  // Context memory
  const contextMemory = new BwContextMemory({
    slots: 8,
    decayMs: 10000,
    featureDim: 128,
    merge: "overwrite",
  });

  // Action selector
  const actionSelector = new BwActionSelector({
    actions: ["HighlightWidget","SuggestTask","CollapseIdle","RefreshFeed","ShowShortcut","Ignore"],
    featureDim: 128,
    temperature: 0.7,
    seed: seed,
  });

  // Effect table
  const effectTable = {};
  effectTable["HighlightWidget"] = function(ctx) { return fx.highlightWidget(ctx); };
  effectTable["SuggestTask"] = function(ctx) { return fx.suggestTask(ctx); };
  effectTable["CollapseIdle"] = function(ctx) { return fx.collapseIdle(ctx); };
  effectTable["RefreshFeed"] = function(ctx) { return fx.refreshFeed(ctx); };
  effectTable["ShowShortcut"] = function(ctx) { return fx.showShortcut(ctx); };
  effectTable["Ignore"] = function() {};

  // Guards
  const guards = new BwGuardChain([{"kind":"max_effects_per_sec","limit":2},{"kind":"suppress_repeats","windowMs":5000}]);

  // Debug overlay + recorder
  const debugOverlay = new BwDebugOverlay(debug);
  const recorder = new BwRecorder();

  let currentCtx = { target: "", eventType: "", features: new Float32Array(128) };
  let lastEvents = [];

  var _bwStats = { ticks: 0, events: 0, actions: 0, lastFpsTime: 0, fps: 0, eventsPerSec: 0, actionsPerSec: 0, _evAcc: 0, _actAcc: 0 };
  var _bwPT = [];

  // Runtime loop
  const loop = new BwRuntimeLoop({"mode":"Interval","ms":1000});

  loop.setSteps([
    // Ingest events
    function ingestStep(now) {
      var _t0 = performance.now();
      var _qLen = eventQueue.getLength();
      lastEvents = eventQueue.drain();
      _bwStats._evAcc += lastEvents.length;
      for (const ev of lastEvents) {
        recorder.recordEvent(ev);
      }
      if (lastEvents.length > 0) debugOverlay.update({ eventQueueLen: _qLen });
      _bwPT[0] = { name: "ingest", durationMs: performance.now() - _t0 };
    },
    // Encode
    function encodeStep(now) {
      var _t0 = performance.now();
      if (lastEvents.length === 0) { _bwPT[1] = { name: "encode", durationMs: 0 }; return; }
      const features = encoder.encode(lastEvents, now);
      const meta = lastEvents.length > 0 ? lastEvents[lastEvents.length - 1].payload : {};
      meta.eventType = lastEvents.length > 0 ? lastEvents[lastEvents.length - 1].type : "";
      currentCtx = contextMemory.step(features, meta, now);
      _bwPT[1] = { name: "encode", durationMs: performance.now() - _t0 };
    },
    // Action selection + effect emission
    function actionStep(now) {
      var _t0 = performance.now();
      // Update tick stats
      _bwStats.ticks++;
      if (now - _bwStats.lastFpsTime >= 500) {
        var dt = (now - _bwStats.lastFpsTime) / 1000;
        if (dt > 0) {
          _bwStats.fps = _bwStats.ticks / dt;
          _bwStats.eventsPerSec = _bwStats._evAcc / dt;
          _bwStats.actionsPerSec = _bwStats._actAcc / dt;
        }
        _bwStats.ticks = 0;
        _bwStats._evAcc = 0;
        _bwStats._actAcc = 0;
        _bwStats.lastFpsTime = now;
      }
      if (lastEvents.length === 0) {
        _bwPT[2] = { name: "action", durationMs: 0 };
        debugOverlay.update({
          tickStats: { fps: _bwStats.fps, eventsPerSec: _bwStats.eventsPerSec, actionsPerSec: _bwStats.actionsPerSec, tickMs: 0 },
          pipelineSteps: _bwPT.slice()
        });
        return;
      }
      const result = actionSelector.step(currentCtx.features);
      const actions = actionSelector.getActions();
      const winner = actions[result.winner];

      // Guard check
      const allowed = guards.check(winner, now);
      if (allowed) _bwStats._actAcc++;

      _bwPT[2] = { name: "action", durationMs: performance.now() - _t0 };
      var _totalTick = 0;
      for (var _ti = 0; _ti < _bwPT.length; _ti++) _totalTick += _bwPT[_ti] ? _bwPT[_ti].durationMs : 0;

      // Debug update
      debugOverlay.update({
        lastEvents: lastEvents,
        contextTarget: currentCtx.target || "",
        contextEventType: currentCtx.eventType || "",
        actionValues: Array.from(result.values),
        actionProbs: Array.from(result.probs),
        actionNames: actions,
        winner: winner,
        guardRejection: allowed ? null : guards.lastRejection,
        featureVector: Array.from(encoder.output),
        encoderOps: encoder.getOpRanges(),
        contextSlots: contextMemory.getSlotInfo(now),
        guardHistory: guards.getRecentEffects(),
        weightMatrix: { weights: Array.from(actionSelector.weights), actions: actions, featureDim: actionSelector.featureDim },
        pipelineSteps: _bwPT.slice(),
        tickStats: { fps: _bwStats.fps, eventsPerSec: _bwStats.eventsPerSec, actionsPerSec: _bwStats.actionsPerSec, tickMs: _totalTick },
      });

      // Record
      recorder.recordAction(now, winner, !allowed);

      // Emit effect
      if (allowed && effectTable[winner]) {
        try {
          effectTable[winner](currentCtx);
          guards.record(winner, now);
        } catch(e) {
          console.error("[BrainWeb] Effect error:", e);
        }
      }
    },
  ]);

  return {
    start: function() {
      cleanupSensors = bwWireSensors(sensorConfigs, eventQueue);
      loop.start();
    },
    stop: function() {
      loop.stop();
      if (cleanupSensors) cleanupSensors();
    },
    startRecording: function() { recorder.start(); },
    stopRecording: function() { return recorder.stop(); },
    replay: function(entries) {
      loop.stop();
      if (cleanupSensors) cleanupSensors();
      cleanupSensors = null;
      for (const entry of entries) {
        if (entry.event) {
          eventQueue.push(entry.event);
        }
      }
      // Run one tick to process all replayed events
      const steps = loop._getSteps ? loop._getSteps() : [];
      const now = performance.now();
      for (const step of steps) step(now);
    },
    getGraph: function() { return __BW_GRAPH__; },
    destroy: function() {
      loop.stop();
      if (cleanupSensors) cleanupSensors();
      debugOverlay.destroy();
    },
  };
}

// Export for browser
if (typeof window !== "undefined") {
  window.BrainWeb = { createApp: createApp };
}