// Generated by BrainWeb Compiler — ClickDemo
// Do not edit by hand.


// ── BrainWeb Runtime (inlined) ──

// MurmurHash3 32-bit
function bwMurmurHash3(key, seed) {
  seed = seed || 0;
  var h = seed >>> 0;
  var len = key.length;
  var i = 0;
  while (i + 4 <= len) {
    var k = (key.charCodeAt(i) & 0xff) |
            ((key.charCodeAt(i+1) & 0xff) << 8) |
            ((key.charCodeAt(i+2) & 0xff) << 16) |
            ((key.charCodeAt(i+3) & 0xff) << 24);
    k = Math.imul(k, 0xcc9e2d51);
    k = (k << 15) | (k >>> 17);
    k = Math.imul(k, 0x1b873593);
    h ^= k;
    h = (h << 13) | (h >>> 19);
    h = Math.imul(h, 5) + 0xe6546b64;
    i += 4;
  }
  var k2 = 0;
  switch (len - i) {
    case 3: k2 ^= (key.charCodeAt(i+2) & 0xff) << 16;
    case 2: k2 ^= (key.charCodeAt(i+1) & 0xff) << 8;
    case 1:
      k2 ^= key.charCodeAt(i) & 0xff;
      k2 = Math.imul(k2, 0xcc9e2d51);
      k2 = (k2 << 15) | (k2 >>> 17);
      k2 = Math.imul(k2, 0x1b873593);
      h ^= k2;
  }
  h ^= len;
  h ^= h >>> 16;
  h = Math.imul(h, 0x85ebca6b);
  h ^= h >>> 13;
  h = Math.imul(h, 0xc2b2ae35);
  h ^= h >>> 16;
  return h >>> 0;
}

// Event Queue
function BwEventQueue() { this.buf = []; }
BwEventQueue.prototype.push = function(ev) { this.buf.push(ev); };
BwEventQueue.prototype.drain = function() {
  if (this.buf.length === 0) return [];
  var events = this.buf; this.buf = []; return events;
};

// Sensor Wiring
function bwCssPath(el) {
  if (!el || el === document.body) return "body";
  var parts = [];
  var cur = el;
  while (cur && cur !== document.body) {
    var sel = cur.tagName.toLowerCase();
    if (cur.id) { sel += "#" + cur.id; parts.unshift(sel); break; }
    if (cur.className && typeof cur.className === "string") {
      sel += "." + cur.className.trim().split(/\s+/).join(".");
    }
    parts.unshift(sel);
    cur = cur.parentElement;
  }
  return parts.join(" > ");
}

var BW_DOM_MAP = {
  Click: "click", Input: "input", KeyDown: "keydown", KeyUp: "keyup",
  Scroll: "scroll", Focus: "focus", Blur: "blur", MouseMove: "mousemove",
  VisibilityChange: "visibilitychange"
};

function bwNormalizePayload(ev) {
  var p = {};
  if (ev instanceof MouseEvent) {
    p.clientX = ev.clientX; p.clientY = ev.clientY; p.button = ev.button;
    p.target = bwCssPath(ev.target);
  } else if (ev instanceof KeyboardEvent) {
    p.key = ev.key; p.code = ev.code; p.target = bwCssPath(ev.target);
  } else if (ev.target && "value" in ev.target) {
    p.inputLen = ev.target.value ? ev.target.value.length : 0;
    p.target = bwCssPath(ev.target);
  }
  if (ev.type === "scroll") { p.scrollY = window.scrollY; p.scrollX = window.scrollX; }
  return p;
}

function bwWireSensors(configs, queue) {
  var cleanups = [];
  for (var i = 0; i < configs.length; i++) {
    var cfg = configs[i];
    for (var j = 0; j < cfg.eventTypes.length; j++) {
      (function(sensorName, evType) {
        var domEv = BW_DOM_MAP[evType];
        if (!domEv) return;
        var handler = function(ev) {
          queue.push({
            sensor: sensorName, type: evType,
            t: performance.now(), payload: bwNormalizePayload(ev)
          });
        };
        document.addEventListener(domEv, handler, { passive: true });
        cleanups.push(function() { document.removeEventListener(domEv, handler); });
      })(cfg.name, cfg.eventTypes[j]);
    }
  }
  return function() { for (var k = 0; k < cleanups.length; k++) cleanups[k](); };
}

// Encoder
function BwEncoder(config) {
  this.dim = config.dim;
  this.ops = config.featureOps;
  this.output = new Float32Array(config.dim);
  this.eventTypeList = config.eventTypeList;
  this.lastEventTime = 0;
}
BwEncoder.prototype.encode = function(events, now) {
  this.output.fill(0);
  if (events.length === 0) return this.output;
  var ev = events[events.length - 1];
  var offset = 0;
  for (var i = 0; i < this.ops.length; i++) {
    var op = this.ops[i];
    switch (op.kind) {
      case "onehot": {
        var idx = this.eventTypeList.indexOf(ev.type);
        var slots = Math.min(this.eventTypeList.length, this.dim - offset);
        if (idx >= 0 && idx < slots) this.output[offset + idx] = 1.0;
        offset += slots;
        break;
      }
      case "bucket": {
        var bins = op.bins || 16;
        var dt = now - this.lastEventTime;
        var normalized = Math.min(dt / 10000, 1.0);
        var bucket = Math.min(Math.floor(normalized * bins), bins - 1);
        if (offset + bucket < this.dim) this.output[offset + bucket] = 1.0;
        offset += bins;
        break;
      }
      case "hash": {
        var buckets = op.buckets || 32;
        var value = String(ev.payload && ev.payload[op.field] || ev.payload && ev.payload.target || "");
        var h = bwMurmurHash3(value, 42);
        var hIdx = h % buckets;
        if (offset + hIdx < this.dim) this.output[offset + hIdx] = 1.0;
        offset += buckets;
        break;
      }
      case "numeric": {
        var val = Number(ev.payload && ev.payload[op.field] || 0);
        var norm = val / (1 + Math.abs(val));
        if (offset < this.dim) this.output[offset] = norm;
        offset += 1;
        break;
      }
      case "clamp": {
        var raw = Number(ev.payload && ev.payload[op.field] || 0);
        var clamped = Math.max(op.min || 0, Math.min(op.max || 1, raw));
        if (offset < this.dim) this.output[offset] = clamped;
        offset += 1;
        break;
      }
      case "scale": {
        var rawV = Number(ev.payload && ev.payload[op.field] || 0);
        if (offset < this.dim) this.output[offset] = rawV * (op.factor || 1);
        offset += 1;
        break;
      }
    }
  }
  this.lastEventTime = now;
  return this.output;
};

// Context Memory
function BwContextMemory(config) {
  this.slots = config.slots;
  this.decayMs = config.decayMs;
  this.featureDim = config.featureDim;
  this.slotData = [];
  this.slotTimes = [];
  this.slotMeta = [];
  this.writeIdx = 0;
  for (var i = 0; i < this.slots; i++) {
    this.slotData.push(new Float32Array(this.featureDim));
    this.slotTimes.push(0);
    this.slotMeta.push({});
  }
}
BwContextMemory.prototype.step = function(features, meta, now) {
  var i, j;
  for (i = 0; i < this.slots; i++) {
    var age = now - this.slotTimes[i];
    if (this.slotTimes[i] > 0 && age > 0) {
      var decay = Math.exp(-age / this.decayMs);
      var d = this.slotData[i];
      for (j = 0; j < this.featureDim; j++) d[j] *= decay;
    }
  }
  var slot = this.slotData[this.writeIdx];
  var copyLen = Math.min(features.length, this.featureDim);
  for (j = 0; j < copyLen; j++) slot[j] = features[j];
  this.slotTimes[this.writeIdx] = now;
  this.slotMeta[this.writeIdx] = Object.assign({}, meta);
  this.writeIdx = (this.writeIdx + 1) % this.slots;

  var aggregated = new Float32Array(this.featureDim);
  var totalW = 0;
  for (i = 0; i < this.slots; i++) {
    if (this.slotTimes[i] === 0) continue;
    var a = now - this.slotTimes[i];
    var w = Math.exp(-a / this.decayMs);
    totalW += w;
    var sd = this.slotData[i];
    for (j = 0; j < this.featureDim; j++) aggregated[j] += sd[j] * w;
  }
  if (totalW > 0) { for (j = 0; j < this.featureDim; j++) aggregated[j] /= totalW; }

  var latestMeta = {}, latestTime = 0;
  for (i = 0; i < this.slots; i++) {
    if (this.slotTimes[i] > latestTime) { latestTime = this.slotTimes[i]; latestMeta = this.slotMeta[i]; }
  }
  return { target: latestMeta.target || "", eventType: latestMeta.eventType || "", features: aggregated };
};

// Action Selector
function bwXorshift32(state) {
  state ^= state << 13;
  state ^= state >> 17;
  state ^= state << 5;
  return state;
}
function bwSoftmax(input, output, temperature) {
  var n = input.length, max = -Infinity;
  for (var i = 0; i < n; i++) { var v = input[i] / temperature; if (v > max) max = v; }
  var sum = 0;
  for (var i = 0; i < n; i++) { var e = Math.exp(input[i] / temperature - max); output[i] = e; sum += e; }
  if (sum > 0) { for (var i = 0; i < n; i++) output[i] /= sum; }
}
function BwActionSelector(config) {
  this.actions = config.actions;
  this.featureDim = config.featureDim;
  this.temperature = config.temperature;
  var n = config.actions.length;
  this.values = new Float32Array(n);
  this.probs = new Float32Array(n);
  this.weights = new Float32Array(n * config.featureDim);
  var rng = config.seed;
  for (var i = 0; i < this.weights.length; i++) {
    rng = bwXorshift32(rng);
    this.weights[i] = ((rng >>> 0) / 0xffffffff - 0.5) * 0.1;
  }
}
BwActionSelector.prototype.step = function(contextFeatures) {
  var n = this.actions.length;
  for (var a = 0; a < n; a++) {
    var sum = 0, base = a * this.featureDim;
    for (var j = 0; j < this.featureDim; j++) {
      sum += this.weights[base + j] * (contextFeatures[j] || 0);
    }
    this.values[a] = sum;
  }
  bwSoftmax(this.values, this.probs, this.temperature);
  var winner = 0, maxVal = this.probs[0];
  for (var a = 1; a < n; a++) {
    if (this.probs[a] > maxVal) { maxVal = this.probs[a]; winner = a; }
  }
  return { winner: winner, values: new Float32Array(this.values), probs: new Float32Array(this.probs) };
};
BwActionSelector.prototype.getActions = function() { return this.actions; };

// Guards
function BwGuardChain(configs) {
  this.configs = configs;
  this.recentEffects = [];
  this.lastRejection = null;
}
BwGuardChain.prototype.check = function(action, now) {
  this.lastRejection = null;
  for (var i = 0; i < this.configs.length; i++) {
    var g = this.configs[i];
    if (g.kind === "max_effects_per_sec") {
      var limit = g.limit || 10;
      var cutoff = now - 1000;
      var count = 0;
      for (var j = 0; j < this.recentEffects.length; j++) {
        if (this.recentEffects[j].t > cutoff) count++;
      }
      if (count >= limit) { this.lastRejection = "max_effects_per_sec (" + count + "/" + limit + ")"; return false; }
    }
    if (g.kind === "suppress_repeats") {
      var windowMs = g.windowMs || 1000;
      var cutoff2 = now - windowMs;
      for (var j = 0; j < this.recentEffects.length; j++) {
        if (this.recentEffects[j].t > cutoff2 && this.recentEffects[j].action === action) {
          this.lastRejection = 'suppress_repeats ("' + action + '" within ' + windowMs + 'ms)';
          return false;
        }
      }
    }
  }
  return true;
};
BwGuardChain.prototype.record = function(action, now) {
  this.recentEffects.push({ t: now, action: action });
  var cutoff = now - 5000;
  while (this.recentEffects.length > 0 && this.recentEffects[0].t < cutoff) this.recentEffects.shift();
};

// Runtime Loop
function BwRuntimeLoop(config) {
  this.config = config;
  this.steps = [];
  this.running = false;
  this.rafId = 0;
  this.intervalId = 0;
}
BwRuntimeLoop.prototype.setSteps = function(steps) { this.steps = steps; };
BwRuntimeLoop.prototype._getSteps = function() { return this.steps; };
BwRuntimeLoop.prototype.start = function() {
  if (this.running) return;
  this.running = true;
  var self = this;
  if (this.config.mode === "RAF") {
    var tick = function() {
      if (!self.running) return;
      var now = performance.now();
      self._runSteps(now);
      self.rafId = requestAnimationFrame(tick);
    };
    this.rafId = requestAnimationFrame(tick);
  } else {
    var ms = this.config.ms || 100;
    this.intervalId = setInterval(function() {
      var now = performance.now();
      self._runSteps(now);
    }, ms);
  }
};
BwRuntimeLoop.prototype.stop = function() {
  this.running = false;
  if (this.rafId) cancelAnimationFrame(this.rafId);
  if (this.intervalId) clearInterval(this.intervalId);
};
BwRuntimeLoop.prototype._runSteps = function(now) {
  for (var i = 0; i < this.steps.length; i++) {
    try { this.steps[i](now); } catch(e) { console.error("[BrainWeb] Step error:", e); this.stop(); return; }
  }
};

// Debug Overlay
function BwDebugOverlay(enabled) {
  this.container = null;
  this.enabled = enabled;
  this.state = {
    lastEvents: [], contextTarget: "", contextEventType: "",
    actionValues: [], actionProbs: [], actionNames: [],
    winner: "", guardRejection: null
  };
  if (enabled && typeof document !== "undefined") this._create();
}
BwDebugOverlay.prototype._create = function() {
  this.container = document.createElement("div");
  this.container.id = "bw-debug-overlay";
  this.container.style.cssText =
    "position:fixed;bottom:0;right:0;width:360px;max-height:50vh;" +
    "overflow-y:auto;background:rgba(15,15,25,0.92);color:#e0e0e0;" +
    "font-family:'SF Mono',Consolas,monospace;font-size:11px;" +
    "padding:10px;z-index:999999;border-top-left-radius:8px;" +
    "border-left:1px solid rgba(100,100,255,0.3);" +
    "border-top:1px solid rgba(100,100,255,0.3);" +
    "backdrop-filter:blur(8px);";
  document.body.appendChild(this.container);
};
BwDebugOverlay.prototype.update = function(partial) {
  for (var k in partial) { if (partial.hasOwnProperty(k)) this.state[k] = partial[k]; }
  if (!this.enabled || !this.container) return;
  this._render();
};
BwDebugOverlay.prototype._render = function() {
  if (!this.container) return;
  var s = this.state;
  var evHtml = s.lastEvents.slice(-5).map(function(e) {
    return '<div style="padding:1px 0;color:#8cf">' + e.sensor + '.' + e.type +
      ' <span style="color:#666">' + (e.payload && e.payload.target || "") + '</span></div>';
  }).join("");
  var actHtml = s.actionNames.map(function(name, i) {
    var isW = name === s.winner;
    var bar = "";
    for (var b = 0; b < Math.round((s.actionProbs[i] || 0) * 20); b++) bar += "\u2588";
    var st = isW ? "color:#5f5;font-weight:bold" : "color:#aaa";
    return '<div style="' + st + '">' + (isW ? "\u25b8" : " ") + " " + name + ": " +
      (s.actionProbs[i] || 0).toFixed(3) + " " + bar + "</div>";
  }).join("");
  var gHtml = s.guardRejection
    ? '<div style="color:#f88;padding:2px 0">\u2298 ' + s.guardRejection + '</div>' : "";
  this.container.innerHTML =
    '<div style="color:#88f;font-weight:bold;margin-bottom:4px">BrainWeb Debug</div>' +
    '<div style="margin-bottom:6px"><div style="color:#888;font-size:10px">EVENTS</div>' +
    (evHtml || '<div style="color:#555">none</div>') + '</div>' +
    '<div style="margin-bottom:6px"><div style="color:#888;font-size:10px">CONTEXT</div>' +
    '<div>target: <span style="color:#cf8">' + (s.contextTarget || "\u2014") + '</span></div>' +
    '<div>event: <span style="color:#cf8">' + (s.contextEventType || "\u2014") + '</span></div></div>' +
    '<div style="margin-bottom:6px"><div style="color:#888;font-size:10px">ACTIONS</div>' +
    (actHtml || '<div style="color:#555">none</div>') + '</div>' +
    gHtml +
    '<div style="margin-top:4px;color:#888;font-size:10px">Winner: <span style="color:#5f5;font-weight:bold">' +
    (s.winner || "\u2014") + '</span></div>';
};
BwDebugOverlay.prototype.destroy = function() {
  if (this.container) this.container.remove();
  this.container = null;
};

// Recorder
function BwRecorder() { this.entries = []; this.recording = false; }
BwRecorder.prototype.start = function() { this.entries = []; this.recording = true; };
BwRecorder.prototype.stop = function() { this.recording = false; return this.entries; };
BwRecorder.prototype.isRecording = function() { return this.recording; };
BwRecorder.prototype.recordEvent = function(ev) {
  if (!this.recording) return;
  this.entries.push({ t: ev.t, event: ev });
};
BwRecorder.prototype.recordAction = function(t, winner, guardRejected) {
  if (!this.recording) return;
  this.entries.push({ t: t, winner: winner, guardRejected: guardRejected });
};


const __BW_GRAPH__ = {
  "name": "ClickDemo",
  "sensors": [
    {
      "name": "UI",
      "eventTypes": [
        "Click",
        "Input",
        "KeyDown"
      ]
    }
  ],
  "encoders": [
    {
      "name": "EventEncoder",
      "inputs": [
        {
          "sensor": "UI",
          "event": "*"
        }
      ],
      "dim": 32,
      "featureOps": [
        {
          "kind": "onehot",
          "field": "EventType"
        },
        {
          "kind": "bucket",
          "field": "TimeDelta",
          "bins": 8
        },
        {
          "kind": "hash",
          "field": "TargetCssPath",
          "buckets": 16
        },
        {
          "kind": "numeric",
          "field": "InputLen"
        }
      ]
    }
  ],
  "modules": [
    {
      "kind": "State",
      "name": "Core__Context",
      "slots": 4,
      "decayMs": 5000,
      "merge": "overwrite"
    },
    {
      "kind": "Rate",
      "name": "ActionGate__ActionValues",
      "units": 3
    },
    {
      "kind": "Rate",
      "name": "ActionGate__Gate",
      "units": 3
    },
    {
      "kind": "ActionSelector",
      "name": "ActionGate",
      "actions": [
        "ShowToast",
        "HighlightTarget",
        "Ignore"
      ],
      "temperature": 1
    }
  ],
  "projections": [
    {
      "from": "ActionGate__ActionValues",
      "to": "ActionGate__Gate",
      "topology": {
        "kind": "softmax",
        "temperature": 1
      },
      "init": {
        "kind": "default"
      }
    }
  ],
  "effectors": [
    {
      "name": "Actions",
      "bindings": [
        {
          "action": "ShowToast",
          "kind": "js",
          "expr": "fx.toast(ctx)"
        },
        {
          "action": "HighlightTarget",
          "kind": "js",
          "expr": "fx.highlight(ctx.target)"
        },
        {
          "action": "Ignore",
          "kind": "noop"
        }
      ]
    }
  ],
  "runtime": {
    "tick": {
      "mode": "RAF"
    },
    "steps": [
      {
        "kind": "ingest",
        "sensors": [
          "UI"
        ]
      },
      {
        "kind": "run",
        "module": "EventEncoder"
      },
      {
        "kind": "run",
        "module": "Core.Context"
      },
      {
        "kind": "run",
        "module": "ActionGate"
      },
      {
        "kind": "emit",
        "effector": "Actions",
        "from": "ActionGate.Gate",
        "winnerOnly": true
      }
    ],
    "guards": [
      {
        "kind": "max_effects_per_sec",
        "limit": 2
      },
      {
        "kind": "suppress_repeats",
        "windowMs": 3000
      }
    ]
  }
};

function createApp(fx, opts) {
  opts = opts || {};
  const seed = opts.seed || 12345;
  const debug = opts.debug !== undefined ? opts.debug : true;

  // Event queue
  const eventQueue = new BwEventQueue();

  // Sensor wiring
  const sensorConfigs = [{"name":"UI","eventTypes":["Click","Input","KeyDown"]}];
  let cleanupSensors = null;

  // Encoder
  const encoder = new BwEncoder({
    dim: 32,
    featureOps: [{"kind":"onehot","field":"EventType"},{"kind":"bucket","field":"TimeDelta","bins":8},{"kind":"hash","field":"TargetCssPath","buckets":16},{"kind":"numeric","field":"InputLen"}],
    eventTypeList: ["Click","Input","KeyDown"],
  });

  // Context memory
  const contextMemory = new BwContextMemory({
    slots: 4,
    decayMs: 5000,
    featureDim: 32,
    merge: "overwrite",
  });

  // Action selector
  const actionSelector = new BwActionSelector({
    actions: ["ShowToast","HighlightTarget","Ignore"],
    featureDim: 32,
    temperature: 1,
    seed: seed,
  });

  // Effect table
  const effectTable = {};
  effectTable["ShowToast"] = function(ctx) { return fx.toast(ctx); };
  effectTable["HighlightTarget"] = function(ctx) { return fx.highlight(ctx.target); };
  effectTable["Ignore"] = function() {};

  // Guards
  const guards = new BwGuardChain([{"kind":"max_effects_per_sec","limit":2},{"kind":"suppress_repeats","windowMs":3000}]);

  // Debug overlay + recorder
  const debugOverlay = new BwDebugOverlay(debug);
  const recorder = new BwRecorder();

  let currentCtx = { target: "", eventType: "", features: new Float32Array(32) };
  let lastEvents = [];

  // Runtime loop
  const loop = new BwRuntimeLoop({"mode":"RAF"});

  loop.setSteps([
    // Ingest events
    function ingestStep(now) {
      lastEvents = eventQueue.drain();
      for (const ev of lastEvents) {
        recorder.recordEvent(ev);
      }
    },
    // Encode
    function encodeStep(now) {
      if (lastEvents.length === 0) return;
      const features = encoder.encode(lastEvents, now);
      const meta = lastEvents.length > 0 ? lastEvents[lastEvents.length - 1].payload : {};
      meta.eventType = lastEvents.length > 0 ? lastEvents[lastEvents.length - 1].type : "";
      currentCtx = contextMemory.step(features, meta, now);
    },
    // Action selection + effect emission
    function actionStep(now) {
      if (lastEvents.length === 0) return;
      const result = actionSelector.step(currentCtx.features);
      const actions = actionSelector.getActions();
      const winner = actions[result.winner];

      // Guard check
      const allowed = guards.check(winner, now);

      // Debug update
      debugOverlay.update({
        lastEvents: lastEvents,
        contextTarget: currentCtx.target || "",
        contextEventType: currentCtx.eventType || "",
        actionValues: Array.from(result.values),
        actionProbs: Array.from(result.probs),
        actionNames: actions,
        winner: winner,
        guardRejection: allowed ? null : guards.lastRejection,
      });

      // Record
      recorder.recordAction(now, winner, !allowed);

      // Emit effect
      if (allowed && effectTable[winner]) {
        try {
          effectTable[winner](currentCtx);
          guards.record(winner, now);
        } catch(e) {
          console.error("[BrainWeb] Effect error:", e);
        }
      }
    },
  ]);

  return {
    start: function() {
      cleanupSensors = bwWireSensors(sensorConfigs, eventQueue);
      loop.start();
    },
    stop: function() {
      loop.stop();
      if (cleanupSensors) cleanupSensors();
    },
    startRecording: function() { recorder.start(); },
    stopRecording: function() { return recorder.stop(); },
    replay: function(entries) {
      loop.stop();
      if (cleanupSensors) cleanupSensors();
      cleanupSensors = null;
      for (const entry of entries) {
        if (entry.event) {
          eventQueue.push(entry.event);
        }
      }
      // Run one tick to process all replayed events
      const steps = loop._getSteps ? loop._getSteps() : [];
      const now = performance.now();
      for (const step of steps) step(now);
    },
    getGraph: function() { return __BW_GRAPH__; },
    destroy: function() {
      loop.stop();
      if (cleanupSensors) cleanupSensors();
      debugOverlay.destroy();
    },
  };
}

// Export for browser
if (typeof window !== "undefined") {
  window.BrainWeb = { createApp: createApp };
}